\section{Desarrolo}%Describe cada una de las funciones que implementaron, respondiendo en profundidad cada una de las preguntas de los Experimentos. Para la descripcion de cada funcion deberan decir como opera una iteracion del ciclo de la funcion. Es decir, como mueven los datos a los registros, como los reordenan para procesarlos, las operaciones que se aplican a los datos, etc. Para esto pueden utilizar pseudocodigo, diagramas (mostrando graficamente el contenido de los registros XMM) o cualquier otro recurso que le sea util para describir la adaptacion del algoritmo al procesamiento simultaneo SIMD. No se debera incluir el codigo assembler de las funciones (aunque se pueden incluir extractos en donde haga falta). Las preguntas en cada ejercicio son una guıa para la confeccion de los resultados obtenidos. Al responder estas preguntas, se deberan analizar y comparar las implementaciones de cada funciones en su version C y ASM, mostrando los resultados obtenidos a traves de tablas y graficos. Tambien se debera comentar acerca de los resultados obtenidos. En el caso de que sucediera que la version en C anduviese mas rapidamente que su version ASM, justificar fuertemente a que se debe esto.



\subsection{Experimentacion(version borrador)}

Usando la herramienta objdump sobre los archivos objeto (.o) del código de c++ (sin flags de optimización), obtuvimos y analizamos el código ensamblado por el compilador.
Cosas que notamos 
\begin{itemize}
	\item Dentro de la función calcVelocities, hay calls a distintas secciones de la función misma que no son necesarios, ya que saltan a una línea consecutiva.
	\item Hay consultas a memorias innecesarias (pide un valor a memoria, que no se pisa y luego de varias operaciones, vuelve a pedirlo).
	\item Se manejan las variables locales almacenandolas en la pila, mientras que sólo se usan los registros de manera auxiliar para realizar operaciones
	%continuar con  como es el codigo generado, como se manipulan las variables locales
\end{itemize}

\newline

Probando compilar el código de c++ con flags de optimización

\begin{itemize}
	\item El código en asembler obtenido mediante la herramienta objdump era reducido en cuanto a cantidad de líneas (por ejemplo, la función calcVelocities tenia 558 líneas en assembler sin flags de optimización y luego con el flag de optimización -O1 341 líneas)
\end{itemize}